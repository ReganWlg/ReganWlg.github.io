{"meta":{"title":"王理庚的博客","subtitle":"","description":"","author":"王理庚","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"数据结构-栈","slug":"数据结构-栈","date":"2020-10-23T03:38:17.000Z","updated":"2020-10-23T08:02:25.378Z","comments":true,"path":"2020/10/23/数据结构-栈/","link":"","permalink":"http://yoursite.com/2020/10/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/","excerpt":"栈的基本概念栈的定义栈（Stack）是只允许在一端进行插入或删除操作的线性表。 栈顶（Top）。线性表允许进行插入删除的那一端。 栈底（Bottom）。固定的，不允许进行插入和删除的另一端。 空栈。不含任何元素的空表。 栈的操作特性：后进先出（Last In First Out，LIFO）。","text":"栈的基本概念栈的定义栈（Stack）是只允许在一端进行插入或删除操作的线性表。 栈顶（Top）。线性表允许进行插入删除的那一端。 栈底（Bottom）。固定的，不允许进行插入和删除的另一端。 空栈。不含任何元素的空表。 栈的操作特性：后进先出（Last In First Out，LIFO）。 栈的基本操作 InitStack(&amp;S)：初始化一个空栈S。 StackEmpty(S)：判断一个栈是否为空，若栈S为空则返回true，否则返回false。 Push(&amp;S, x)：进栈，若栈S未满，则将x加入使之成为新栈顶。 Pop(&amp;S, &amp;x)：出栈，若栈S非空，则弹出栈顶元素，并用x返回。 GetTop(S, &amp;x)：读栈顶元素，若栈S非空，则用x返回栈顶元素。 DestroyStack(&amp;S)：销毁栈，并释放栈S所占用的存储空间。 栈的顺序存储结构顺序栈的实现采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针（top）指示当前栈顶元素的位置。 栈的顺序存储类型可描述为 12345#define MaxSize 50 // 定义栈中元素的最大个数typedef struct &#123; ElemType data[MaxSize]; //存放栈中的元素 int top; // 栈顶指针&#125; SqStack; 栈顶指针：S.top，初始时设置S.top=-1；栈顶元素即为S.data[S.top]。 进栈操作：栈不满时，栈顶指针先加1，再送值到栈顶元素。 出栈操作：栈非空时，先取栈顶元素值，再将栈顶指针减1. 栈空条件：S.top==-1；栈满条件：S.top==MaxSize-1；栈长：S.top+1。 顺序栈的基本操作的实现初始化123void InitStack(SqStack &amp;S) &#123; S.top = -1; // 初始化栈顶指针&#125; 判栈空12345678bool StackEmpty(SqStack S) &#123; if (S.top == -1) &#123; // 栈空 return true; &#125; else &#123; // 栈不空 return false; &#125;&#125; 进栈1234567bool Push(SqStack &amp;S, ElemType x) &#123; if (S.top == MaxSize - 1) // 栈满，报错 return false; S.top++; // 指针先加1，再入栈 S.data[S.top] = x; return true;&#125; 出栈1234567bool Pop(SqStack &amp;S, ElemType &amp;x) &#123; if (S.top == -1) // 栈空，报错 return false; x = S.data[S.top]; // 先出栈 S.top--; // 指针再减1 return true;&#125; 读栈顶元素123456bool GetTop(SqStack S, ElemType &amp;x) &#123; if (S.top == -1) // 栈空，报错 return false; x = S.data[S.top]; // x记录栈顶元素 return true;&#125; 仅仅是读取栈顶元素，并没有出栈的操作，因此原栈顶元素依然保留在栈中。 栈的链式存储结构采用链式存储的栈称为链栈，链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。通常采用单链表实现，并规定所有操作都是在单链表的表头进行。这里规定链栈没有头结点，Lhead指向栈顶元素。 栈的链式存储类型可描述为 1234typedef struct LinkNode &#123; Elemtype data; // 数据域 struct LinkNode *next; // 指针域&#125; *LiStack; // 栈类型定义 入栈和出栈的操作都在链表的表头进行。","categories":[],"tags":[]},{"title":"hexo博客创建、部署到本地及云端","slug":"hexo博客创建、部署到本地及云端","date":"2020-10-07T11:21:03.000Z","updated":"2020-10-07T13:39:32.293Z","comments":true,"path":"2020/10/07/hexo博客创建、部署到本地及云端/","link":"","permalink":"http://yoursite.com/2020/10/07/hexo%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E3%80%81%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%AC%E5%9C%B0%E5%8F%8A%E4%BA%91%E7%AB%AF/","excerpt":"创建hexo n &quot;博客名&quot; 或者 hexo new &quot;博客名&quot; 部署到本地hexo clean 这句可以没有 hexo g 或者 hexo generate 本地查看","text":"创建hexo n &quot;博客名&quot; 或者 hexo new &quot;博客名&quot; 部署到本地hexo clean 这句可以没有 hexo g 或者 hexo generate 本地查看hexo s 或者 hexo server 部署到云端hexo d 或者 hexo deploy","categories":[],"tags":[]},{"title":"数据结构--线性表","slug":"数据结构-线性表","date":"2020-10-07T11:02:00.000Z","updated":"2020-10-14T08:00:53.194Z","comments":true,"path":"2020/10/07/数据结构-线性表/","link":"","permalink":"http://yoursite.com/2020/10/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/","excerpt":"线性表的定义和基本操作线性表的特点 表中元素的个数有限。 表中元素具有逻辑上的顺序性，表中元素有其先后次序。 表中元素都是数据元素，每个元素都是单个元素。 表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间。 表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容。 线性表的基本操作 InitList(&amp;L)：初始化表。 Length(L)：求表长。 LocateElem(L, e)：按值查找。查找给定关键字值的元素 GetElem(L, i)：按位查找。获取第i个位置的元素的值 ListInsert(&amp;L, i, e)：插入操作。在第i个位置上插入指定元素e。 ListDelete(&amp;L, i, &amp;e)：删除操作。删除第i个位置的元素，并用e返回删除元素的值。 PrintList(L)：输出操作。顺序输出所有元素值。 Empty(L)：判空操作。若L为空表，则返回true，否则返回false。 DestroyList(&amp;L)：销毁操作。销毁线性表，并释放线性表L所占用的内存空间","text":"线性表的定义和基本操作线性表的特点 表中元素的个数有限。 表中元素具有逻辑上的顺序性，表中元素有其先后次序。 表中元素都是数据元素，每个元素都是单个元素。 表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间。 表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容。 线性表的基本操作 InitList(&amp;L)：初始化表。 Length(L)：求表长。 LocateElem(L, e)：按值查找。查找给定关键字值的元素 GetElem(L, i)：按位查找。获取第i个位置的元素的值 ListInsert(&amp;L, i, e)：插入操作。在第i个位置上插入指定元素e。 ListDelete(&amp;L, i, &amp;e)：删除操作。删除第i个位置的元素，并用e返回删除元素的值。 PrintList(L)：输出操作。顺序输出所有元素值。 Empty(L)：判空操作。若L为空表，则返回true，否则返回false。 DestroyList(&amp;L)：销毁操作。销毁线性表，并释放线性表L所占用的内存空间 线性表的顺序表示顺序表的定义线性表的顺序存储又称顺序表。它的特点是表中元素的逻辑顺序与其物理顺序相同。 静态分配12345#define MaxSize 50 // 线性表最大长度typedef struct &#123; ElemType data[MaxSize]; // 顺序表的元素 int length; // 顺序表的当前长度&#125; SqList; 动态分配123456#define InitSize 100 // 表长度的初始定义typedef struct &#123; ElemType *data; // 指示动态分配数组的指针 int MaxSize; // 数组的最大容量 int length; // 数组的当前长度&#125; SeqList; C语言的初始动态分配语句为 1L.data = (ElemType*)malloc(sizeof(ElemType) * InitSize); C++的初始动态分配语句为 1L.data = new ElemType[InitSize]; 顺序表的特点 顺序表最主要的特点是随机访问，即通过首地址和元素符号可在时间$O(1)$内找到指定的元素。 顺序表的存储密度高，每个结点只存储数据元素。 顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素。 顺序表上基本操作的实现插入操作注意：在顺序表的第i个位置插入新元素e，此时下标应该是i-1 12345678910111213bool ListInsert(SqList &amp;L, int i, ElemType e) &#123; if (i &lt; 1 || i &gt; L.length + 1) return false; if (L.length &gt;= MaxSize) return false; int j; for (j = L.length; j &gt;= i; j--) &#123; L.data[j] = L.data[j - 1]; &#125; L.data[i - 1] = e; L.length++; return true;&#125; 顺序表插入算法的平均时间复杂度为$O(n)$。 删除操作1234567891011bool ListDelete(SqList &amp;L, int i, ElemType &amp;e) &#123; if (i &lt; 1 || i &gt; L.length + 1) return false; e = L.data[i - 1]; int j; for (j = i; j &lt; L.length; j++) &#123; L.data[j] = L.data[j + 1]; &#125; L.length--; return true;&#125; 顺序表删除算法的平均时间复杂度为$O(n)$。 按值查找（顺序查找）注意：若查到下标为i的是结果，则返回的位序是i+1 12345678int LocateElem(SqList L, ElemType e) &#123; int i; for (i = 0; i &lt; L.length; i++) &#123; if (L.data[i] == e) return i + 1; &#125; return 0;&#125; 顺序表按值查找算法的平均时间复杂度为$O(n)$。 线性表的链式表示单链表的定义每个链表结点，除了存放元素自身的信息外，还需要存放一个指向其后继的指针。 | data | next | data为数据域，存放数据元素；next为指针域，存放其后继节点的地址。 单链表中节点类型的描述如下 1234typedef struct LNode &#123; ElemType data; // 数据域 struct LNode *next; // 指针域&#125; LNode, *LinkList; 单链表的元素离散地分布在存储空间中，是非随机存取的存储结构。 利用单链表可以解决顺序表需要大量连续存储单元的缺点，但由于单链表附加指针域，也存在浪费存储空间的缺点。 单链表上基本操作的实现头插法建立单链表123456789101112131415LinkList List_HeadInsert(LinkList &amp;L) &#123; LNode *s; int x; L = (LinkList)malloc(sizeof(LNode)); // 创建头结点 L-&gt;next = NULL; // 初始为空链表 scanf(\"%d\", &amp;x); // 输入结点的值 while (x != 9999) &#123; // 终止条件 s = (LNode*)malloc(sizeof(LNode)); // 创建新结点 s-&gt;data = x; s-&gt;next = L-&gt;next; L-&gt;next = s; // 将新结点插入表中，L为头指针 scanf(\"%d\", &amp;x); &#125; return L;&#125; 注意： 头插法建立单链表时，读入数据的顺序与生成的链表中的元素的顺序是相反的。 每个结点插入的时间为$O(1)$，则总时间复杂度为$O(n)$。 尾插法建立单链表123456789101112131415LinkList List_TailInsert(LinkList &amp;L) &#123; int x; L = (LinkList)malloc(sizeof(LNode)); LNode *s, *r = L; // r为表尾指针 scanf(\"%d\", &amp;x); while (x != 9999) &#123; s = (LNode*)malloc(sizeof(LNode)); // 创建新结点 s-&gt;data = x; r-&gt;next = s; r = s; // r指向新的表尾结点 scanf(\"%d\", &amp;x); &#125; r-&gt;next = NULL; // 尾结点指针置空 return L;&#125; 注意： 生成的结点的次序和输入数据的顺序一致，但需要增加一个尾指针r，使其始终指向当前链表的尾结点。 时间复杂度与头插法相同。 按序号查找结点值12345678910111213LNode *GetElem(LinkList L, int i) &#123; int j = 1; // 计数器，初始为1 LNode *p = L-&gt;next; // 头结点的指针赋给p if (i == 0) return L; // 若i=0，返回头结点 if (i &lt; 1) // 若i&lt;1，说明无效，返回NULL return NULL; while (p &amp;&amp; j &lt; i) &#123; // 从第1个结点开始找，查找第i个结点 p = p-&gt;next; j++; &#125; return p; // 返回第i个结点的指针，若i大于表长则返回NULL&#125; 时间复杂度为$O(n)$。 按值查找表结点1234567LNode *LocateElem(LinkList L, ElemType e) &#123; LNode *p = L-&gt;next; while (p != NULL &amp;&amp; p-&gt;data != e) &#123; p = p-&gt;next; &#125; return p; // 找到后返回该结点指针，否则返回NULL&#125; 时间复杂度为$O(n)$。 插入结点12345678910111213bool ListInsert(LinkList &amp;L, int i, ElemType e) &#123; LNode *p = GetElem(L, i - 1); // 查找插入位置的前驱结点 if (p == NULL) &#123; // 插入失败 return false; &#125; else &#123; // 插入成功 LNode *s = (LinkList)malloc(sizeof(LNode)); //创建新结点 s-&gt;data = e; s-&gt;next = p-&gt;next; p-&gt;next = s; // 将新结点插入表中 return true; &#125;&#125; 注意 本算法主要的时间开销在于查找第i-1个元素，时间复杂度为$O(n)$。若在给定的结点后面插入新结点，则时间复杂度仅为$O(1)$。 删除结点1234567891011121314bool DeleteInsert(LinkList &amp;L, int i, ElemType &amp;e) &#123; LNode *p = GetElem(L, i - 1); LNode *q; if (p == NULL) &#123; // 删除失败 return false; &#125; else &#123; // 删除成功 q = p-&gt;next; p-&gt;next = q-&gt;next; // 删除结点 e = q-&gt;data; // e为被删除结点的值 free(q); // 释放结点 return true; &#125;&#125; 时间复杂度与插入算法相同 求表长123456789int Length(LinkList L) &#123; LNode *p = L-&gt;next; int length = 0; while (p != NULL) &#123; length++; p = p-&gt;next; &#125; return length;&#125; 注意：单链表的长度是不包括头结点的 双链表由于单链表结点中只有一个指向其后继的指针，使得其只能从头结点依次顺序地向后遍历。当要访问某个节点的前驱结点（插入、删除操作时），只能从头开始遍历，导致访问后继节点的时间复杂度为$O(1)$，而访问前驱结点的时间复杂度为$O(n)$。 为了克服单链表的上述缺点，引入双链表，双链表结点中有两个指针prior和next，分别指向其前驱结点和后继结点。 双链表中结点类型的描述如下： 1234typedef struct DNode &#123; ElemType data; // 数据域 struct DNode *prior, *next; // 前驱和后继指针&#125; DNode, *DLinklist; 注意：双链表在单链表的结点中增加了一个指向其前驱的prior指针，按值查找和按位查找操作与单链表相同。但双链表在插入和删除操作的实现上，与单链表有着较大的不同，关键是要对prior指针做出修改，保证不断链。双链表的插入和删除操作的时间复杂度为$O(1)$。 双链表的插入操作123456789101112131415bool ListInsert(DLinkList &amp;L, int i, ElemType e) &#123; DNode *p = GetElem(L, i - 1); // 查找插入位置的前驱结点 if (p == NULL) &#123; // 插入失败 return false; &#125; else &#123; // 插入成功 DNode *s = (DLinkList)malloc(sizeof(DNode)); //创建新结点 s-&gt;data = e; s-&gt;next = p-&gt;next; p-&gt;next-&gt;prior = s; // 相对于单链表的插入操作新增的语句 s-&gt;prior = p; // 相对于单链表的插入操作新增的语句 p-&gt;next = s; // 将新结点插入表中 return true; &#125;&#125; 双链表的删除操作123456789101112131415bool DeleteInsert(DLinkList &amp;L, int i, ElemType &amp;e) &#123; DNode *p = GetElem(L, i - 1); DNode *q; if (p == NULL) &#123; // 删除失败 return false; &#125; else &#123; // 删除成功 q = p-&gt;next; p-&gt;next = q-&gt;next; // 删除结点 q-&gt;next-&gt;prior = p; // 相对于单链表的删除操作新增的语句。 e = q-&gt;data; // e为被删除结点的值 free(q); // 释放结点 return true; &#125;&#125; 循环链表循环单链表循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头节点，从而整个链表形成一个环。 循环单链表的判空条件不是头结点的指针是否为空，而是它是否等于头指针 循环单链表的插入、删除算法与单链表几乎一样 循环单链表可以从表中的任意一个结点开始遍历整个链表。 有时对单链表的操作是在表头和表尾进行的，此时对循环单链表不设头指针而仅设尾指针，从而使操作效率更高。原因是，若设的是头指针，对表尾进行操作需要$O(n)$的时间复杂度，而若设尾指针r，r-&gt;next即为头指针，对于表头和表尾进行操作都只需要$O(1)$的时间复杂度。 循环双链表循环双链表中，头结点的prior指针还要指向表尾结点。 在循环双链表L中，某结点*p为尾结点时，p-&gt;next==L；当循环双链表为空表时，其头结点的prior域和next域都等于L。 静态链表静态链表借助数组来描述线性表的链式存储结构，结点也有数据域data和指针域next，与前面的链表中的指针不同的是，这里的指针是结点的相对地址（数组下标），又称游标。和顺序表一样，静态链表也要预先分配一块连续的地址空间。 静态链表结构类型的描述如下： 12345#define MaxSize 50 // 静态链表的最大长度typedef struct &#123; ElemType data; // 存储数据元素 int next; // 下一个元素的数组下标&#125; SLinkList[MaxSize]; 静态链表以$next==-1$作为其结束标志。静态链表的插入、删除操作与动态链表的相同，只需要修改指针，而不需要移动元素。总体来说，静态链表没有单链表使用起来方便，但是在一些不支持指针的高级语言（如Basic）中，这是一种非常巧妙的设计方法。 顺序表和链表的比较存取（读写）方式顺序表仅需一次访问，而链表则需从表头开始依次访问i次。 逻辑结构与物理结构顺序存储时，逻辑上相邻的元素，对应的物理存储位置也相邻；链式存储时，逻辑上相邻的元素，物理存储位置不一定相邻，对应的逻辑关系是通过指针链接来表示的。 查找、插入和删除操作对于按值查找，顺序表无序时，二者时间复杂度均为$O(n)$；顺序表有序时，可采用折半查找，此时时间复杂度为$O(log_{2}n$)。 空间分配顺序存储 静态存储时，若存储空间预先分配过大，可能会导致顺序表后部大量闲置；预先分配过小，又会造成内存溢出。 动态存储时，虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且若内存中没有更大块的连续存储空间，则会导致分配失败。 链式存储 结点空间只在需要时申请分配，只要内存有空间就可以分配，操作灵活、高效。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-04-15T08:26:34.261Z","updated":"2020-03-11T05:41:20.000Z","comments":true,"path":"2020/04/15/hello-world/","link":"","permalink":"http://yoursite.com/2020/04/15/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"使用IntelliJ IDEA创建Vue项目","slug":"使用Intelli-IDEA创建Vue项目","date":"2020-03-17T08:33:13.000Z","updated":"2020-03-17T13:41:48.000Z","comments":true,"path":"2020/03/17/使用Intelli-IDEA创建Vue项目/","link":"","permalink":"http://yoursite.com/2020/03/17/%E4%BD%BF%E7%94%A8Intelli-IDEA%E5%88%9B%E5%BB%BAVue%E9%A1%B9%E7%9B%AE/","excerpt":"一、创建项目 打开IntelliJ IDEA创建一个Static Web项目 打开Termital终端，输入 1vue -V 可以检查vue版本 二、安装项目 在终端中输入 1vue init webpack VueDemo 共九个配置项 123456789? Project name vuedemo? Project description A Vue.js project? Author ReganWlg &lt;1959411673@qq.com&gt;? Vue build standalone? Install vue-router? Yes? Use ESLint to lint your code? No? Set up unit tests No? Setup e2e tests with Nightwatch? No? Should we run &#96;npm install&#96; for you after the project has been created? (recommended) no 前5个直接回车回车回车，后4个no 进入项目目录 1cd VueDemo 初始化项目 1npm install 运行项目 1cnpm run dev 打开http://localhost:8080","text":"一、创建项目 打开IntelliJ IDEA创建一个Static Web项目 打开Termital终端，输入 1vue -V 可以检查vue版本 二、安装项目 在终端中输入 1vue init webpack VueDemo 共九个配置项 123456789? Project name vuedemo? Project description A Vue.js project? Author ReganWlg &lt;1959411673@qq.com&gt;? Vue build standalone? Install vue-router? Yes? Use ESLint to lint your code? No? Set up unit tests No? Setup e2e tests with Nightwatch? No? Should we run &#96;npm install&#96; for you after the project has been created? (recommended) no 前5个直接回车回车回车，后4个no 进入项目目录 1cd VueDemo 初始化项目 1npm install 运行项目 1cnpm run dev 打开http://localhost:8080 三、配置IDEA File - Settings - Languages&amp;Frameworks - JavaScript: 修改JavaScript language为ECMAScript 6 Run - Edit Configurations…: 点击加号，选择npm，Name为dev，package.json选择工程中的package.json，Command为run，Scripts为dev，然后就可以直接在IDEA中运行了 再点击加号，选择npm，Name为build，package.json选择工程中的package.json，Command为run，Scripts为build，然后就可以直接在IDEA中打包了","categories":[],"tags":[]},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2020-03-11T06:22:14.000Z","updated":"2020-03-11T06:29:06.000Z","comments":true,"path":"2020/03/11/我的第一篇博客文章/","link":"","permalink":"http://yoursite.com/2020/03/11/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"第一章内容 第二章内容","text":"第一章内容 第二章内容 参考文献www.codesheep.cn","categories":[],"tags":[]}],"categories":[],"tags":[]}